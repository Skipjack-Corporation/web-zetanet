{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t(require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"react\"], t) : (e = e || self).ReactSlideToggle = t(e.React);\n}(this, function (e) {\n  \"use strict\";\n\n  function t(e, t) {\n    for (var a = 0; a < t.length; a++) {\n      var s = t[a];\n      s.enumerable = s.enumerable || !1, s.configurable = !0, \"value\" in s && (s.writable = !0), Object.defineProperty(e, s.key, s);\n    }\n  }\n\n  function a(e, t, a) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: a,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = a, e;\n  }\n\n  function s(e) {\n    return (s = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    })(e);\n  }\n\n  function o(e, t) {\n    return (o = Object.setPrototypeOf || function (e, t) {\n      return e.__proto__ = t, e;\n    })(e, t);\n  }\n\n  function r(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }\n\n  e = e && e.hasOwnProperty(\"default\") ? e.default : e;\n\n  var n = \"undefined\" != typeof window ? window : global,\n      i = n.requestAnimationFrame ? n.requestAnimationFrame.bind(n) : function (e) {\n    return n.setTimeout(e, 16);\n  },\n      l = n.cancelAnimationFrame ? n.cancelAnimationFrame.bind(n) : n.clearInterval.bind(n),\n      p = Object.freeze({\n    EXPANDED: \"EXPANDED\",\n    COLLAPSED: \"COLLAPSED\",\n    EXPANDING: \"EXPANDING\",\n    COLLAPSING: \"COLLAPSING\"\n  }),\n      g = function (e) {\n    return e < .5 ? 4 * e * e * e : .5 * Math.pow(2 * e - 2, 3) + 1;\n  },\n      u = {\n    isMoving: function (e) {\n      return e === p.EXPANDING || e === p.COLLAPSING;\n    },\n    clamp: function (e) {\n      var t = e.value,\n          a = e.max,\n          s = void 0 === a ? 1 : a,\n          o = e.min,\n          r = void 0 === o ? 0 : o;\n      return t > s ? s : t < r ? r : t;\n    },\n    now: function () {\n      return Date.now();\n    },\n    sanitizeDuration: function (e) {\n      return Math.max(0, parseInt(+e, 10) || 0);\n    },\n    interpolate: function (e) {\n      var t = e.next,\n          a = e.prev,\n          s = Math.abs(t - a),\n          o = t;\n      return s > .15 && (t > a ? o -= .75 * s : o += .75 * s), o;\n    }\n  },\n      c = function (n) {\n    function g() {\n      var e, t, o, n;\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, g);\n\n      for (var l = arguments.length, c = new Array(l), d = 0; d < l; d++) c[d] = arguments[d];\n\n      return o = this, n = (e = s(g)).call.apply(e, [this].concat(c)), t = !n || \"object\" != typeof n && \"function\" != typeof n ? r(o) : n, a(r(t), \"_state_\", {\n        collapsibleElement: null,\n        toggleState: t.props.collapsed ? p.COLLAPSED : p.EXPANDED\n      }), a(r(t), \"GET_HEIGHT\", t.props.offsetHeight ? \"offsetHeight\" : \"scrollHeight\"), a(r(t), \"state\", {\n        toggleState: t._state_.toggleState,\n        hasReversed: !1,\n        range: t.props.collapsed ? 0 : 1,\n        progress: t.props.collapsed ? 0 : 1\n      }), a(r(t), \"getCollapsible\", function () {\n        return t._state_.collapsibleElement;\n      }), a(r(t), \"updateCollapsible\", function (e, a) {\n        t.getCollapsible() && (t._state_.collapsibleElement.style[e] = a);\n      }), a(r(t), \"setCollapsibleElement\", function (e) {\n        t._state_.collapsibleElement = e, t._state_.toggleState === p.COLLAPSED && t.setCollapsedState({\n          initialState: !0\n        });\n      }), a(r(t), \"onToggle\", function () {\n        if (!t.props.irreversible || !u.isMoving(t._state_.toggleState)) {\n          var e = function () {\n            t.props.onCollapsing && t.props.onCollapsing({\n              range: t.state.range,\n              progress: t.state.progress,\n              hasReversed: t.state.hasReversed\n            }), t.collapse();\n          },\n              a = function () {\n            t.props.onExpanding && t.props.onExpanding({\n              range: t.state.range,\n              progress: t.state.progress,\n              hasReversed: t.state.hasReversed\n            }), t.expand();\n          },\n              s = function (e) {\n            var a = e.toggleState,\n                s = e.display,\n                o = e.hasReversed;\n            t._state_.toggleState = a, t._state_.hasReversed = !!o, void 0 === s || t.props.noDisplayStyle || t.updateCollapsible(\"display\", s);\n            var r = u.now();\n\n            if (o) {\n              var n = t._state_.startTime,\n                  i = u.sanitizeDuration(t.props.duration),\n                  l = Math.min(i, r - n),\n                  p = Math.max(0, i - l);\n              t._state_.startTime = r - p;\n            } else {\n              var g = t.getCollapsible();\n              g && g.style.height && t.updateCollapsible(\"height\", null), t._state_.boxHeight = g ? g[t.GET_HEIGHT] : 0, t._state_.startTime = r, t._state_.startDirection = a;\n            }\n\n            t.setState({\n              toggleState: t._state_.toggleState,\n              hasReversed: t._state_.hasReversed\n            });\n          };\n\n          switch (t._state_.toggleState) {\n            case p.EXPANDED:\n              s({\n                toggleState: p.COLLAPSING\n              }), e();\n              break;\n\n            case p.COLLAPSED:\n              s({\n                toggleState: p.EXPANDING,\n                display: \"\"\n              }), a();\n              break;\n\n            case p.EXPANDING:\n              s({\n                toggleState: p.COLLAPSING,\n                hasReversed: !0\n              }), e();\n              break;\n\n            case p.COLLAPSING:\n              s({\n                toggleState: p.EXPANDING,\n                display: \"\",\n                hasReversed: !0\n              }), a();\n          }\n        }\n      }), a(r(t), \"setExpandedState\", function () {\n        t._state_.progress = 1, t._state_.toggleState = p.EXPANDED, t.updateCollapsible(\"height\", null), t.setState({\n          toggleState: p.EXPANDED,\n          range: 1,\n          progress: t._state_.progress\n        }), t.props.onExpanded && t.props.onExpanded({\n          hasReversed: t.state.hasReversed\n        });\n      }), a(r(t), \"expand\", function () {\n        if (t._state_.toggleState === p.EXPANDING) {\n          var e = u.sanitizeDuration(t.props.duration);\n          if (e <= 0) t.setExpandedState();else {\n            var a = t._state_.startTime,\n                s = Math.min(e, u.now() - a);\n            if (s >= e) t.setExpandedState();else {\n              var o,\n                  r = t._state_,\n                  n = r.startDirection,\n                  i = r.toggleState,\n                  l = r.boxHeight,\n                  g = u.clamp({\n                value: s / e\n              });\n              o = t.props.whenReversedUseBackwardEase && n !== i ? 1 - t.props.easeCollapse(1 - g) : t.props.easeExpand(g), t.props.bestPerformance || t.setState({\n                range: g,\n                progress: o\n              }), t.props.interpolateOnReverse && t._state_.hasReversed && (o = u.interpolate({\n                next: o,\n                prev: t._state_.progress\n              }));\n              var c = Math.round(l * o);\n              t._state_.progress = o, t.updateCollapsible(\"height\", \"\".concat(c, \"px\")), t.nextTick(t.expand);\n            }\n          }\n        }\n      }), a(r(t), \"setCollapsedState\", function () {\n        var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).initialState;\n        t._state_.progress = 0, t._state_.toggleState = p.COLLAPSED, t.props.noDisplayStyle ? t.updateCollapsible(\"height\", \"0px\") : (t.updateCollapsible(\"display\", \"none\"), t.updateCollapsible(\"height\", null)), t.setState({\n          toggleState: p.COLLAPSED,\n          range: 0,\n          progress: t._state_.progress\n        }), !e && t.props.onCollapsed && t.props.onCollapsed({\n          hasReversed: t.state.hasReversed\n        });\n      }), a(r(t), \"collapse\", function () {\n        if (t._state_.toggleState === p.COLLAPSING) {\n          var e = u.sanitizeDuration(t.props.duration);\n          if (e <= 0) t.setCollapsedState();else {\n            var a = t._state_.startTime,\n                s = Math.min(e, u.now() - a);\n            if (s >= e) t.setCollapsedState();else {\n              var o,\n                  r = t._state_,\n                  n = r.startDirection,\n                  i = r.boxHeight,\n                  l = r.toggleState,\n                  g = 1 - u.clamp({\n                value: s / e\n              }),\n                  c = t.props,\n                  d = c.whenReversedUseBackwardEase,\n                  _ = c.easeExpand,\n                  f = c.easeCollapse;\n              o = d && n !== l ? _(g) : 1 - f(1 - g), t.props.bestPerformance || t.setState({\n                range: g,\n                progress: o\n              }), t.props.interpolateOnReverse && t._state_.hasReversed && (o = u.interpolate({\n                next: o,\n                prev: t._state_.progress\n              }));\n              var h = Math.round(i * o);\n              t._state_.progress = o, t._state_.timeout = t.nextTick(t.collapse), t.updateCollapsible(\"height\", \"\".concat(h, \"px\"));\n            }\n          }\n        }\n      }), a(r(t), \"nextTick\", function (e) {\n        t._state_.timeout = i(e);\n      }), t;\n    }\n\n    var c, d, _;\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && o(e, t);\n    }(g, e.Component), c = g, (d = [{\n      key: \"render\",\n      value: function () {\n        var e = {\n          onToggle: this.onToggle,\n          setCollapsibleElement: this.setCollapsibleElement,\n          toggleState: this.state.toggleState,\n          hasReversed: this.state.hasReversed,\n          isMoving: u.isMoving(this.state.toggleState),\n          range: this.state.range,\n          progress: this.state.progress\n        };\n        return this.props.children ? this.props.children(e) : this.props.render ? this.props.render(e) : null;\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function () {\n        this._state_.timeout && l(this._state_.timeout);\n      }\n    }]) && t(c.prototype, d), _ && t(c, _), g;\n  }();\n\n  return a(c, \"defaultProps\", {\n    duration: 300,\n    easeCollapse: g,\n    easeExpand: g\n  }), c;\n});","map":null,"metadata":{},"sourceType":"script"}